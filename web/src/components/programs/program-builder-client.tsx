'use client'

import { useState, useCallback, useMemo, useRef } from 'react'
import { useRouter } from 'next/navigation'
import { AppLayout } from '@/components/layout'
import { createClient } from '@/lib/supabase/client'
import { WorkoutPanel } from './workout-panel'
import { arrayMove, SortableContext, horizontalListSortingStrategy } from '@dnd-kit/sortable'
import { DndContext, closestCenter, PointerSensor, TouchSensor, useSensor, useSensors } from '@dnd-kit/core'
import type { DragEndEvent } from '@dnd-kit/core'
import { SortableWorkoutTab } from './sortable-workout-tab'
import { ExerciseLibraryPanel } from './exercise-library-panel'
import { VolumeSummary } from './volume-summary'
import { Button } from '@/components/ui/button'
import { ChevronLeft, Loader2, Calendar, Edit3, AlertCircle, BookmarkPlus } from 'lucide-react'

import { TourRunner } from '@/components/onboarding/tours/tour-runner'
import { TOUR_STEPS } from '@/components/onboarding/tours/tour-definitions'
import { useOnboardingStore } from '@/stores/onboarding-store'
import type { Exercise } from '@/types/exercise'
import { assignProgram } from '@/app/students/[id]/actions/assign-program'

export interface WorkoutItem {
    id: string
    item_type: 'exercise' | 'superset' | 'note'
    order_index: number
    parent_item_id: string | null
    exercise_id: string | null
    substitute_exercise_ids: string[]
    exercise?: Exercise
    sets: number | null
    reps: string | null
    rest_seconds: number | null
    notes: string | null
    children?: WorkoutItem[]
}

export interface Workout {
    id: string
    name: string
    order_index: number
    items: WorkoutItem[]
    frequency?: string[] // ['mon', 'tue', etc]
}

interface ProgramData {
    id: string
    name: string
    description: string | null
    duration_weeks: number | null
    workout_templates?: Array<{
        id: string
        name: string
        order_index: number
        frequency?: string[]
        workout_item_templates?: Array<{
            id: string
            item_type: string
            order_index: number
            parent_item_id: string | null
            exercise_id: string | null
            substitute_exercise_ids?: string[] | null
            sets: number | null
            reps: string | null
            rest_seconds: number | null
            notes: string | null
        }>
    }>
}

interface Trainer {
    id: string
    name: string
    email: string
    avatar_url?: string | null
    theme?: 'light' | 'dark' | 'system' | null
}

interface StudentContext {
    id: string
    name: string
    activeProgramName?: string | null
}

interface ProgramBuilderClientProps {
    trainer: Trainer
    program: ProgramData | null
    exercises: Exercise[]
    studentContext?: StudentContext
    initialAssignmentType?: 'immediate' | 'scheduled'
    /** When present, the program was generated by the AI prescription engine */
    prescriptionGenerationId?: string
}

// Generate temp ID for new items
const tempId = () => `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

export function ProgramBuilderClient({ trainer, program, exercises, studentContext, initialAssignmentType = 'immediate', prescriptionGenerationId }: ProgramBuilderClientProps) {
    const router = useRouter()
    const isEditing = !!program && !!program.id && !program.id.startsWith('temp_')
    const isStudentContext = !!studentContext

    // Local exercises state to support inline creation
    const [localExercises, setLocalExercises] = useState<Exercise[]>(exercises)

    // Program state
    const [name, setName] = useState(program?.name || '')
    const [description, setDescription] = useState(program?.description || '')
    const [durationWeeks, setDurationWeeks] = useState(program?.duration_weeks?.toString() || '4')
    const [startDate, setStartDate] = useState(new Date().toISOString().split('T')[0])
    const [isEndDateFixed, setIsEndDateFixed] = useState(false)
    const [assignmentType] = useState<'immediate' | 'scheduled'>(initialAssignmentType)
    const [isDescriptionOpen, setIsDescriptionOpen] = useState(false)
    const [showActivateConfirm, setShowActivateConfirm] = useState(false)
    const [showTemplateDialog, setShowTemplateDialog] = useState(false)
    const [templateName, setTemplateName] = useState('')
    const [alsoActivate, setAlsoActivate] = useState(false)
    const [savingTemplate, setSavingTemplate] = useState(false)

    // Helper to calculate end date from weeks
    const calculateEndDate = useCallback((start: string, weeksStr: string) => {
        const startObj = new Date(start)
        const weeks = parseInt(weeksStr) || 0
        if (isNaN(startObj.getTime())) return ''
        const endObj = new Date(startObj)
        endObj.setDate(endObj.getDate() + (weeks * 7) - 1)
        return endObj.toISOString().split('T')[0]
    }, [])

    // Helper to calculate weeks from end date
    const calculateWeeks = useCallback((start: string, end: string) => {
        const startObj = new Date(start)
        const endObj = new Date(end)
        if (isNaN(startObj.getTime()) || isNaN(endObj.getTime())) return '0'
        const diffTime = endObj.getTime() - startObj.getTime()
        const diffDays = Math.max(0, Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1)
        return Math.round(diffDays / 7).toString()
    }, [])

    const [endDate, setEndDate] = useState(() =>
        calculateEndDate(new Date().toISOString().split('T')[0], program?.duration_weeks?.toString() || '4')
    )

    // Handlers for bidirectional sync
    const handleWeeksChange = (weeks: string) => {
        const weeksNum = Math.max(0, parseInt(weeks) || 0)
        const weeksStr = weeksNum.toString()

        setDurationWeeks(weeksStr)
        const newEnd = calculateEndDate(startDate, weeksStr)
        setEndDate(newEnd)
    }

    const handleEndDateChange = (end: string) => {
        // Prevent end date being before start date
        if (new Date(end) < new Date(startDate)) {
            // Reset to start date + 0 weeks
            const resetEnd = calculateEndDate(startDate, '0')
            setEndDate(resetEnd)
            setDurationWeeks('0')
            return
        }

        setEndDate(end)
        setIsEndDateFixed(true)
        const newWeeks = calculateWeeks(startDate, end)
        setDurationWeeks(newWeeks)
    }

    const handleStartDateChange = (start: string) => {
        setStartDate(start)
        const newEnd = calculateEndDate(start, durationWeeks)
        setEndDate(newEnd)
    }

    // Initialize workouts helper
    const initializeWorkouts = (): Workout[] => {
        console.log('Initializing workouts with program:', program?.workout_templates)
        if (!program?.workout_templates || program.workout_templates.length === 0) {
            return [{
                id: tempId(),
                name: 'Treino A',
                order_index: 0,
                items: [],
                frequency: []
            }]
        }

        return program.workout_templates
            .sort((a, b) => a.order_index - b.order_index)
            .map(wt => {
                const rawItems = wt.workout_item_templates || []
                const parents = rawItems.filter(i => !i.parent_item_id)
                const children = rawItems.filter(i => i.parent_item_id)

                const items: WorkoutItem[] = parents
                    .sort((a, b) => a.order_index - b.order_index)
                    .map(p => {
                        const itemChildren = children
                            .filter(c => c.parent_item_id === p.id)
                            .sort((a, b) => a.order_index - b.order_index)
                            .map(c => ({
                                id: c.id,
                                item_type: c.item_type as 'exercise' | 'superset' | 'note',
                                order_index: c.order_index,
                                parent_item_id: c.parent_item_id,
                                exercise_id: c.exercise_id,
                                substitute_exercise_ids: c.substitute_exercise_ids || [],
                                exercise: c.exercise_id ? exercises.find(e => e.id === c.exercise_id) : undefined,
                                sets: c.sets,
                                reps: c.reps,
                                rest_seconds: c.rest_seconds,
                                notes: c.notes,
                            }))

                        return {
                            id: p.id,
                            item_type: p.item_type as 'exercise' | 'superset' | 'note',
                            order_index: p.order_index,
                            parent_item_id: p.parent_item_id,
                            exercise_id: p.exercise_id,
                            substitute_exercise_ids: p.substitute_exercise_ids || [],
                            exercise: p.exercise_id ? exercises.find(e => e.id === p.exercise_id) : undefined,
                            sets: p.sets,
                            reps: p.reps,
                            rest_seconds: p.rest_seconds,
                            notes: p.notes,
                            children: itemChildren
                        }
                    })

                return {
                    id: wt.id,
                    name: wt.name,
                    order_index: wt.order_index,
                    frequency: wt.frequency || [],
                    items
                }
            })
    }

    const [workouts, setWorkouts] = useState<Workout[]>(initializeWorkouts)
    const [activeWorkoutId, setActiveWorkoutId] = useState<string | null>(
        workouts.length > 0 ? workouts[0].id : null
    )
    const [saving, setSaving] = useState(false)
    const [error, setError] = useState<string | null>(null)
    const [nameShake, setNameShake] = useState(false)
    const [isCanvasScrolled, setIsCanvasScrolled] = useState(false)
    const [isDraggingOver, setIsDraggingOver] = useState(false)
    const canvasScrollRef = useRef<HTMLDivElement>(null)
    // Sensors for tab drag-and-drop (distance constraint allows click without triggering drag)
    const tabSensors = useSensors(
        useSensor(PointerSensor, { activationConstraint: { distance: 5 } }),
        useSensor(TouchSensor),
    )

    // Derived state
    const activeWorkout = useMemo(() =>
        workouts.find(w => w.id === activeWorkoutId) || null
        , [workouts, activeWorkoutId])

    const occupiedDays = useMemo(() => {
        const days = new Set<string>()
        workouts.forEach(w => {
            if (activeWorkoutId !== w.id && w.frequency) {
                w.frequency.forEach(d => days.add(d))
            }
        })
        return Array.from(days)
    }, [workouts, activeWorkoutId])

    // Actions
    const addWorkout = useCallback(() => {
        const newWorkout: Workout = {
            id: tempId(),
            name: `Treino ${String.fromCharCode(65 + workouts.length)}`,
            order_index: workouts.length,
            items: [],
            frequency: []
        }
        setWorkouts(prev => [...prev, newWorkout])
        setActiveWorkoutId(newWorkout.id)
    }, [workouts.length])

    const updateWorkoutName = useCallback((workoutId: string, name: string) => {
        setWorkouts(prev => prev.map(w =>
            w.id === workoutId ? { ...w, name } : w
        ))
    }, [])

    const deleteWorkout = useCallback((workoutId: string) => {
        const remaining = workouts.filter(w => w.id !== workoutId)
        setWorkouts(remaining.map((w, i) => ({ ...w, order_index: i })))
        if (activeWorkoutId === workoutId) {
            setActiveWorkoutId(remaining[0]?.id || null)
        }
    }, [activeWorkoutId, workouts])

    const duplicateWorkout = useCallback((workoutId: string) => {
        setWorkouts(prev => {
            const source = prev.find(w => w.id === workoutId)
            if (!source) return prev
            const baseName = source.name.replace(/^(Treino [A-Z]|Dia \d+)\s*[-–]\s*/, '')
            const copy: Workout = {
                id: tempId(),
                name: `Treino ${String.fromCharCode(65 + prev.length)}${baseName ? ` - ${baseName}` : ''}`,
                order_index: prev.length,
                items: source.items.map(item => ({
                    ...item,
                    id: tempId(),
                    children: item.children?.map(child => ({ ...child, id: tempId() })),
                })),
                frequency: [],
            }
            return [...prev, copy]
        })
    }, [])

    const handleWorkoutDragEnd = useCallback((event: DragEndEvent) => {
        const { active, over } = event
        if (!over || active.id === over.id) return
        setWorkouts(prev => {
            const oldIndex = prev.findIndex(w => w.id === active.id)
            const newIndex = prev.findIndex(w => w.id === over.id)
            if (oldIndex === -1 || newIndex === -1) return prev
            return arrayMove(prev, oldIndex, newIndex).map((w, i) => ({ ...w, order_index: i }))
        })
    }, [])

    const updateWorkoutFrequency = useCallback((workoutId: string, days: string[]) => {
        console.log('updateWorkoutFrequency', workoutId, days)
        setWorkouts(prev => prev.map(w =>
            w.id === workoutId ? { ...w, frequency: days } : w
        ))
    }, [])

    const addExerciseFromLibrary = useCallback((exercise: Exercise) => {
        if (!activeWorkoutId) return

        setWorkouts(prev => prev.map(w => {
            if (w.id !== activeWorkoutId) return w

            const newItem: WorkoutItem = {
                id: tempId(),
                item_type: 'exercise',
                order_index: 0, // Will be recalculated
                parent_item_id: null,
                exercise_id: exercise.id,
                substitute_exercise_ids: [],
                exercise: exercise,
                sets: 3,
                reps: '10',
                rest_seconds: 60,
                notes: null,
                children: []
            }

            // Normal add to root
            return {
                ...w,
                items: [...w.items, { ...newItem, order_index: w.items.length }]
            }
        }))
    }, [activeWorkoutId])

    const handleExerciseCreated = useCallback((newExercise: Exercise) => {
        setLocalExercises(prev => [newExercise, ...prev])
    }, [])

    // Handle drag-and-drop from exercise library to workout canvas
    const handleCanvasDragOver = useCallback((e: React.DragEvent) => {
        if (e.dataTransfer.types.includes('application/kinevo-exercise-id')) {
            e.preventDefault()
            e.dataTransfer.dropEffect = 'copy'
            setIsDraggingOver(true)
        }
    }, [])

    const handleCanvasDragLeave = useCallback((e: React.DragEvent) => {
        // Only trigger when leaving the container, not child elements
        if (!e.currentTarget.contains(e.relatedTarget as Node)) {
            setIsDraggingOver(false)
        }
    }, [])

    const handleCanvasDrop = useCallback((e: React.DragEvent) => {
        e.preventDefault()
        setIsDraggingOver(false)
        const exerciseId = e.dataTransfer.getData('application/kinevo-exercise-id')
        if (!exerciseId) return
        const exercise = localExercises.find(ex => ex.id === exerciseId)
        if (exercise) {
            addExerciseFromLibrary(exercise)
        }
    }, [localExercises, addExerciseFromLibrary])

    const addNote = useCallback((workoutId: string) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w
            const newItem: WorkoutItem = {
                id: tempId(),
                item_type: 'note',
                order_index: w.items.length,
                parent_item_id: null,
                exercise_id: null,
                substitute_exercise_ids: [],
                sets: null,
                reps: null,
                rest_seconds: null,
                notes: '',
                children: []
            }
            return { ...w, items: [...w.items, newItem] }
        }))
    }, [])

    const updateItem = useCallback((workoutId: string, itemId: string, updates: Partial<WorkoutItem>) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const newItems = w.items.map(item => {
                if (item.id === itemId) return { ...item, ...updates }
                if (item.children) {
                    const newChildren = item.children.map(c =>
                        c.id === itemId ? { ...c, ...updates } : c
                    )
                    return { ...item, children: newChildren }
                }
                return item
            })

            return { ...w, items: newItems }
        }))
    }, [])

    const deleteItem = useCallback((workoutId: string, itemId: string) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const newItems = w.items.filter(item => item.id !== itemId).map(item => ({
                ...item,
                children: item.children ? item.children.filter(c => c.id !== itemId) : []
            }))

            return { ...w, items: newItems }
        }))
    }, [])

    const moveItem = useCallback((workoutId: string, itemId: string, direction: 'up' | 'down') => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const index = w.items.findIndex(i => i.id === itemId)
            if (index !== -1) {
                const targetIndex = direction === 'up' ? index - 1 : index + 1
                if (targetIndex >= 0 && targetIndex < w.items.length) {
                    const newItems = [...w.items]
                    const temp = newItems[index]
                    newItems[index] = newItems[targetIndex]
                    newItems[targetIndex] = temp
                    return { ...w, items: newItems.map((item, i) => ({ ...item, order_index: i })) }
                }
            }
            return w
        }))
    }, [])

    const handleReorderItem = useCallback((activeId: string, overId: string) => {
        if (!activeWorkoutId) return

        setWorkouts(prev => prev.map(w => {
            if (w.id !== activeWorkoutId) return w

            const oldIndex = w.items.findIndex(i => i.id === activeId)
            const newIndex = w.items.findIndex(i => i.id === overId)

            if (oldIndex !== -1 && newIndex !== -1 && oldIndex !== newIndex) {
                const newItems = arrayMove(w.items, oldIndex, newIndex)
                return { ...w, items: newItems.map((item, i) => ({ ...item, order_index: i })) }
            }
            return w
        }))
    }, [activeWorkoutId])

    const createSupersetWithNext = useCallback((workoutId: string, itemId: string) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const index = w.items.findIndex(i => i.id === itemId)
            if (index === -1 || index === w.items.length - 1) return w

            const currentItem = w.items[index]
            const nextItem = w.items[index + 1]
            if (currentItem.item_type !== 'exercise' || nextItem.item_type !== 'exercise') return w

            const supersetId = tempId()
            const superset: WorkoutItem = {
                id: supersetId,
                item_type: 'superset',
                order_index: index,
                parent_item_id: null,
                exercise_id: null,
                substitute_exercise_ids: [],
                sets: null,
                reps: null,
                rest_seconds: null,
                notes: null,
                children: [
                    { ...currentItem, parent_item_id: supersetId, order_index: 0 },
                    { ...nextItem, parent_item_id: supersetId, order_index: 1 }
                ]
            }

            const newItems = [...w.items]
            newItems.splice(index, 2, superset)

            return { ...w, items: newItems.map((i, idx) => ({ ...i, order_index: idx })) }
        }))
    }, [])

    const dissolveSuperset = useCallback((workoutId: string, supersetId: string) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const index = w.items.findIndex(i => i.id === supersetId)
            if (index === -1) return w

            const superset = w.items[index]
            if (!superset.children) return w

            const children = superset.children.map(c => ({
                ...c,
                parent_item_id: null
            }))

            const newItems = [...w.items]
            newItems.splice(index, 1, ...children)
            return { ...w, items: newItems.map((i, idx) => ({ ...i, order_index: idx })) }
        }))
    }, [])

    const addToExistingSuperset = useCallback((workoutId: string, itemId: string, supersetId: string) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const itemIndex = w.items.findIndex(i => i.id === itemId)
            const supersetIndex = w.items.findIndex(i => i.id === supersetId)

            if (itemIndex === -1 || supersetIndex === -1) return w

            const item = w.items[itemIndex]
            const superset = w.items[supersetIndex]

            // Create new child with parent reference
            const newChild = {
                ...item,
                parent_item_id: supersetId,
                order_index: (superset.children?.length || 0)
            }

            // Update superset children
            const newChildren = [...(superset.children || []), newChild]
                .map((c, i) => ({ ...c, order_index: i }))

            const updatedSuperset = {
                ...superset,
                children: newChildren
            }

            // Remove original item and update superset
            const newItems = [...w.items]
            // If item is before superset, remove first then update superset index
            if (itemIndex < supersetIndex) {
                newItems.splice(supersetIndex, 1, updatedSuperset)
                newItems.splice(itemIndex, 1)
            } else {
                newItems.splice(itemIndex, 1)
                newItems.splice(supersetIndex, 1, updatedSuperset)
            }

            return { ...w, items: newItems.map((i, idx) => ({ ...i, order_index: idx })) }
        }))
    }, [])

    const removeFromSuperset = useCallback((workoutId: string, supersetId: string, itemId: string) => {
        setWorkouts(prev => prev.map(w => {
            if (w.id !== workoutId) return w

            const supersetIndex = w.items.findIndex(i => i.id === supersetId)
            if (supersetIndex === -1) return w

            const superset = w.items[supersetIndex]
            if (!superset.children) return w

            const childIndex = superset.children.findIndex(c => c.id === itemId)
            if (childIndex === -1) return w

            const child = superset.children[childIndex]

            // Remove from children
            const newChildren = superset.children.filter(c => c.id !== itemId)

            // If superset becomes empty or has only 1 child, handle dissolution logic if needed
            // For now just keep it or let user dissolve manually if empty

            const updatedSuperset = {
                ...superset,
                children: newChildren.map((c, i) => ({ ...c, order_index: i }))
            }

            // Add child back to root items after superset
            const newItem = {
                ...child,
                parent_item_id: null,
            }

            const newItems = [...w.items]
            newItems.splice(supersetIndex, 1, updatedSuperset)
            newItems.splice(supersetIndex + 1, 0, newItem)

            return { ...w, items: newItems.map((i, idx) => ({ ...i, order_index: idx })) }
        }))
    }, [])


    // Save program — overrideType allows buttons to pass the assignment type directly
    const saveProgram = async (overrideType?: 'immediate' | 'scheduled') => {
        const effectiveAssignmentType = overrideType ?? assignmentType
        if (!name.trim()) {
            setError('Por favor, preencha o nome do programa.')
            setNameShake(true)
            setTimeout(() => setNameShake(false), 600)
            return
        }

        setSaving(true)
        setError(null)

        const supabase = createClient()

        try {
            // ... existing save logic ...
            let programId = program?.id

            if (isEditing) {
                // Update existing program
                const { error: updateError } = await supabase
                    .from('program_templates')
                    .update({
                        name: name.trim(),
                        description: description.trim() || null,
                        duration_weeks: durationWeeks ? parseInt(durationWeeks) : null,
                    })
                    .eq('id', programId)

                if (updateError) throw updateError

                // Delete existing workouts (cascade will delete items)
                await supabase
                    .from('workout_templates')
                    .delete()
                    .eq('program_template_id', programId)
            } else {
                // Create new program
                // is_template: true if saving as template OR not in student context
                const isTemplate = !isStudentContext

                const { data: newProgram, error: createError } = await supabase
                    .from('program_templates')
                    .insert({
                        name: name.trim(),
                        description: description.trim() || null,
                        duration_weeks: durationWeeks ? parseInt(durationWeeks) : null,
                        is_template: isTemplate,
                    })
                    .select('id')
                    .single()

                if (createError) throw createError
                programId = newProgram.id
            }

            // Save workouts and items
            for (const workout of workouts) {
                console.log('Saving workout:', workout.name, 'Frequency:', workout.frequency)
                const { data: savedWorkout, error: workoutError } = await supabase
                    .from('workout_templates')
                    .insert({
                        program_template_id: programId,
                        name: workout.name,
                        order_index: workout.order_index,
                        frequency: workout.frequency
                    })
                    .select('id')
                    .single()

                if (workoutError) throw workoutError

                // Save items
                for (const item of workout.items) {
                    const { data: savedItem, error: itemError } = await supabase
                        .from('workout_item_templates')
                        .insert({
                            workout_template_id: savedWorkout.id,
                            item_type: item.item_type,
                            order_index: item.order_index,
                            parent_item_id: null,
                            exercise_id: item.exercise_id,
                            substitute_exercise_ids: item.substitute_exercise_ids || [],
                            sets: item.sets,
                            reps: item.reps,
                            rest_seconds: item.rest_seconds,
                            notes: item.notes,
                        })
                        .select('id')
                        .single()

                    if (itemError) throw itemError

                    // Save children (for supersets)
                    if (item.children) {
                        for (const child of item.children) {
                            const { error: childError } = await supabase
                                .from('workout_item_templates')
                                .insert({
                                    workout_template_id: savedWorkout.id,
                                    item_type: child.item_type,
                                    order_index: child.order_index,
                                    parent_item_id: savedItem.id,
                                    exercise_id: child.exercise_id,
                                    substitute_exercise_ids: child.substitute_exercise_ids || [],
                                    sets: child.sets,
                                    reps: child.reps,
                                    rest_seconds: child.rest_seconds,
                                    notes: child.notes,
                                })

                            if (childError) throw childError
                        }
                    }
                }
            }

            // Auto-assign to student if in student context
            if (isStudentContext && studentContext && programId) {
                // Prepare schedule map
                const workoutSchedule: Record<number, number[]> = {}
                workouts.forEach(w => {
                    const days = w.frequency || []
                    if (days.length > 0) {
                        const dayMap: Record<string, number> = { 'sun': 0, 'mon': 1, 'tue': 2, 'wed': 3, 'thu': 4, 'fri': 5, 'sat': 6 }
                        workoutSchedule[w.order_index] = days
                            .map(d => dayMap[d])
                            .filter(d => d !== undefined)
                    }
                })

                const result = await assignProgram({
                    studentId: studentContext.id,
                    templateId: programId,
                    startDate: new Date(startDate).toISOString(),
                    isScheduled: effectiveAssignmentType === 'scheduled',
                    workoutSchedule,
                    prescriptionGenerationId,
                })

                if (!result.success) {
                    console.error('Auto-assign error:', result.error)
                    // Don't throw - program was saved, just assignment failed
                    setError(`Programa salvo, mas erro ao atribuir: ${result.error}`)
                    return // Stop redirection to show error
                }

                // Mark both milestones: program created AND assigned
                useOnboardingStore.getState().completeMilestone('first_program_created')
                useOnboardingStore.getState().completeMilestone('first_program_assigned')

                router.push(`/students/${studentContext.id}`)
            } else {
                // Template saved (no assignment)
                useOnboardingStore.getState().completeMilestone('first_program_created')
                router.push('/programs')
            }
            router.refresh()
        } catch (err: unknown) {
            // Supabase PostgrestError is a plain object, not instanceof Error
            const message = err instanceof Error
                ? err.message
                : typeof err === 'object' && err !== null && 'message' in err
                    ? String((err as any).message)
                    : 'Erro ao salvar programa'
            console.error('Save program error:', message, err)
            setError(message)
        } finally {
            setSaving(false)
        }
    }

    // Save current program structure as a reusable template
    const saveAsTemplate = async () => {
        if (!templateName.trim()) return

        setSavingTemplate(true)
        setError(null)

        const supabase = createClient()

        try {
            // 1. Create template in program_templates with is_template = true
            const { data: newTemplate, error: createError } = await supabase
                .from('program_templates')
                .insert({
                    name: templateName.trim(),
                    description: description.trim() || null,
                    duration_weeks: durationWeeks ? parseInt(durationWeeks) : null,
                    is_template: true,
                })
                .select('id')
                .single()

            if (createError) throw createError

            // 2. Save workouts and items (same structure as saveProgram)
            for (const workout of workouts) {
                const { data: savedWorkout, error: workoutError } = await supabase
                    .from('workout_templates')
                    .insert({
                        program_template_id: newTemplate.id,
                        name: workout.name,
                        order_index: workout.order_index,
                        frequency: workout.frequency,
                    })
                    .select('id')
                    .single()

                if (workoutError) throw workoutError

                for (const item of workout.items) {
                    const { data: savedItem, error: itemError } = await supabase
                        .from('workout_item_templates')
                        .insert({
                            workout_template_id: savedWorkout.id,
                            item_type: item.item_type,
                            order_index: item.order_index,
                            parent_item_id: null,
                            exercise_id: item.exercise_id,
                            substitute_exercise_ids: item.substitute_exercise_ids || [],
                            sets: item.sets,
                            reps: item.reps,
                            rest_seconds: item.rest_seconds,
                            notes: item.notes,
                        })
                        .select('id')
                        .single()

                    if (itemError) throw itemError

                    if (item.children) {
                        for (const child of item.children) {
                            const { error: childError } = await supabase
                                .from('workout_item_templates')
                                .insert({
                                    workout_template_id: savedWorkout.id,
                                    item_type: child.item_type,
                                    order_index: child.order_index,
                                    parent_item_id: savedItem.id,
                                    exercise_id: child.exercise_id,
                                    substitute_exercise_ids: child.substitute_exercise_ids || [],
                                    sets: child.sets,
                                    reps: child.reps,
                                    rest_seconds: child.rest_seconds,
                                    notes: child.notes,
                                })
                            if (childError) throw childError
                        }
                    }
                }
            }

            setShowTemplateDialog(false)

            // 3. Optionally also activate for the student
            if (alsoActivate && isStudentContext && studentContext) {
                // Use the existing saveProgram flow with 'immediate'
                await saveProgram('immediate')
            } else {
                // Just show success and stay on page
                setError(null)
                alert('Modelo salvo na biblioteca!')
            }
        } catch (err: unknown) {
            const message = err instanceof Error
                ? err.message
                : typeof err === 'object' && err !== null && 'message' in err
                    ? String((err as any).message)
                    : 'Erro ao salvar modelo'
            console.error('Save template error:', message, err)
            setError(message)
        } finally {
            setSavingTemplate(false)
        }
    }

    return (
        <AppLayout
            trainerName={trainer.name}
            trainerEmail={trainer.email}
            trainerAvatarUrl={trainer.avatar_url}
            trainerTheme={trainer.theme ?? undefined}
        >
            <div className="flex flex-col h-[calc(100vh-64px)] overflow-hidden bg-surface-canvas">
                {/* Compact Header */}
                <div className="flex-shrink-0 bg-surface-primary backdrop-blur-md border-b border-k-border-primary flex items-center gap-4 px-6 py-3 z-30">
                    {/* Left: Back + Name */}
                    <div className="flex items-center gap-3 min-w-0">
                        <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => isStudentContext && studentContext
                                ? router.push(`/students/${studentContext.id}`)
                                : router.push('/programs')
                            }
                            className="w-9 h-9 rounded-full hover:bg-glass-bg-active text-k-text-tertiary hover:text-k-text-primary transition-all flex-shrink-0"
                        >
                            <ChevronLeft className="w-5 h-5" />
                        </Button>

                        <div className="flex items-center gap-2 min-w-0">
                            <input
                                type="text"
                                value={name}
                                onChange={(e) => {
                                    setName(e.target.value)
                                    if (error) setError(null)
                                }}
                                placeholder="Nome do programa"
                                className={`bg-transparent border-none text-lg font-bold text-k-text-primary placeholder:text-k-text-quaternary focus:ring-0 p-0 min-w-[140px] max-w-[280px] truncate transition-all ${nameShake ? 'animate-[shake_0.5s_ease-in-out]' : ''
                                    } ${error && !name.trim() ? 'placeholder:text-red-400/60' : ''}`}
                            />
                            <button
                                onClick={() => setIsDescriptionOpen(!isDescriptionOpen)}
                                className={`p-1 rounded-md transition-all shrink-0 ${isDescriptionOpen ? 'bg-violet-500/20 text-violet-400' : 'text-k-text-quaternary hover:text-k-text-tertiary hover:bg-glass-bg'
                                    }`}
                                title="Editar descrição"
                            >
                                <Edit3 className="w-3.5 h-3.5" strokeWidth={2.5} />
                            </button>
                        </div>
                    </div>

                    {/* Center: Condensed timeline (only in student context) */}
                    {isStudentContext && (
                        <div className="flex items-center gap-2 text-xs text-k-text-tertiary border-x border-k-border-subtle px-6 shrink-0">
                            <Calendar className="w-3.5 h-3.5 text-k-text-quaternary shrink-0" strokeWidth={1.5} />
                            <span className="text-[10px] text-k-text-quaternary font-medium uppercase">Início</span>
                            <input
                                type="date"
                                value={startDate}
                                onChange={(e) => handleStartDateChange(e.target.value)}
                                className="bg-transparent border-none text-xs font-bold text-k-text-primary focus:ring-0 p-0 [color-scheme:dark] w-[110px]"
                            />
                            <span className="text-k-border-subtle">→</span>
                            <span className="text-[10px] text-k-text-quaternary font-medium uppercase">Fim</span>
                            <input
                                type="date"
                                value={endDate}
                                onChange={(e) => handleEndDateChange(e.target.value)}
                                className={`bg-transparent border-none text-xs font-bold focus:ring-0 p-0 [color-scheme:dark] w-[110px] transition-colors ${isEndDateFixed ? 'text-violet-400' : 'text-k-text-primary'}`}
                            />
                            <span className="text-k-border-subtle">·</span>
                            <div className="flex items-center gap-1">
                                <input
                                    type="number"
                                    value={durationWeeks}
                                    onChange={(e) => handleWeeksChange(e.target.value)}
                                    min="0"
                                    className="bg-transparent border-none text-xs font-black text-violet-400 focus:ring-0 p-0 w-6 text-center"
                                />
                                <span className="text-k-text-quaternary font-medium">semanas</span>
                            </div>
                        </div>
                    )}

                    {/* Right: Actions — context-aware save buttons */}
                    <div className="flex items-center gap-3 ml-auto flex-shrink-0">
                        {isStudentContext ? (
                            <>
                                {/* Terciário: Salvar Modelo — text button com ícone */}
                                <button
                                    onClick={() => {
                                        setTemplateName(name)
                                        setAlsoActivate(false)
                                        setShowTemplateDialog(true)
                                    }}
                                    disabled={saving}
                                    className="flex items-center gap-1.5 px-3 py-2 h-9 text-sm text-k-text-quaternary hover:text-k-text-primary transition-colors disabled:opacity-50"
                                >
                                    <BookmarkPlus className="w-4 h-4" />
                                    Salvar Modelo
                                </button>

                                {/* Secundário: Agendar na Fila — cinza sólido */}
                                <Button
                                    onClick={() => saveProgram('scheduled')}
                                    disabled={saving}
                                    variant="ghost"
                                    className="rounded-xl px-5 py-2 h-9 text-sm font-medium bg-white/[0.08] text-white hover:bg-white/[0.14] transition-all"
                                >
                                    Agendar na Fila
                                </Button>

                                {/* Primário: Ativar como Atual — roxo sólido */}
                                <div data-onboarding="program-save">
                                    <Button
                                        onClick={() => {
                                            if (studentContext?.activeProgramName) {
                                                setShowActivateConfirm(true)
                                            } else {
                                                saveProgram('immediate')
                                            }
                                        }}
                                        disabled={saving}
                                        className="bg-violet-600 hover:bg-violet-500 text-white rounded-xl px-5 py-2 h-9 text-sm font-medium transition-all"
                                    >
                                        {saving ? (
                                            <Loader2 className="animate-spin w-4 h-4" />
                                        ) : (
                                            'Ativar como Atual'
                                        )}
                                    </Button>
                                </div>
                            </>
                        ) : (
                            <div data-onboarding="program-save">
                                <Button
                                    onClick={() => saveProgram()}
                                    disabled={saving}
                                    className="bg-violet-600 hover:bg-violet-500 text-white rounded-xl px-5 py-2 h-9 text-sm font-medium transition-all min-w-[130px]"
                                >
                                    {saving ? (
                                        <Loader2 className="animate-spin w-4 h-4" />
                                    ) : (
                                        'Salvar'
                                    )}
                                </Button>
                            </div>
                        )}
                    </div>
                </div>

                {/* Header-based Description Area */}
                {isDescriptionOpen && (
                    <div className="flex-shrink-0 bg-surface-primary border-b border-k-border-subtle px-8 py-4 animate-in slide-in-from-top-4 duration-300">
                        <div className="max-w-3xl">
                            <label className="block text-[10px] font-bold text-k-text-quaternary uppercase tracking-widest mb-2">Descrição do Programa</label>
                            <textarea
                                value={description}
                                onChange={(e) => setDescription(e.target.value)}
                                placeholder="Adicione detalhes sobre o objetivo, metodologia ou observações gerais..."
                                className="w-full bg-glass-bg border border-k-border-subtle rounded-xl px-4 py-3 text-sm text-k-text-primary placeholder:text-k-border-subtle focus:ring-1 focus:ring-violet-500/50 focus:border-violet-500/30 transition-all min-h-[80px] resize-none"
                            />
                        </div>
                    </div>
                )}

                {/* Error Banner */}
                {error && (
                    <div className="flex-shrink-0 mx-6 mt-3 bg-red-500/10 border border-red-500/20 text-red-400 px-4 py-3 rounded-xl text-sm flex items-center gap-3 animate-in fade-in slide-in-from-top-2 duration-300">
                        <AlertCircle className="w-4 h-4 flex-shrink-0" />
                        <span className="font-medium">{error}</span>
                        <button
                            onClick={() => setError(null)}
                            className="ml-auto text-red-400/60 hover:text-red-400 transition-colors text-xs font-bold"
                        >
                            ✕
                        </button>
                    </div>
                )}

                <div data-onboarding="program-volume">
                    <VolumeSummary workouts={workouts} />
                </div>

                {/* Workspace (Layout Columns) */}
                <div className="flex flex-1 overflow-hidden">
                    {/* Left Panel: Exercise Library */}
                    <div data-onboarding="program-exercise-library" className="w-[320px] bg-surface-primary border-r border-k-border-subtle flex flex-col flex-shrink-0">
                        <ExerciseLibraryPanel
                            exercises={localExercises}
                            trainerId={trainer.id}
                            onAddExercise={addExerciseFromLibrary}
                            onExerciseCreated={handleExerciseCreated}
                            activeWorkoutId={activeWorkoutId}
                        />
                    </div>

                    {/* Right Panel: Canvas */}
                    <div className="flex-1 flex flex-col min-w-0 bg-surface-canvas">
                        {/* Workout Tabs (Sortable Segmented Control) */}
                        <div data-onboarding="program-workouts" className="flex items-center gap-1 p-4 overflow-x-auto no-scrollbar border-b border-k-border-subtle bg-surface-canvas">
                            <DndContext sensors={tabSensors} collisionDetection={closestCenter} onDragEnd={handleWorkoutDragEnd}>
                                <SortableContext items={workouts.map(w => w.id)} strategy={horizontalListSortingStrategy}>
                                    <div className="bg-surface-card p-1 rounded-xl flex gap-1 items-center border border-k-border-subtle">
                                        {workouts.map((workout) => (
                                            <SortableWorkoutTab key={workout.id} id={workout.id}>
                                                <button
                                                    onClick={() => setActiveWorkoutId(workout.id)}
                                                    className={`
                                                        px-4 py-1.5 text-xs font-semibold rounded-lg transition-all whitespace-nowrap flex items-center gap-2
                                                        ${activeWorkoutId === workout.id
                                                            ? 'bg-glass-bg-active text-k-text-primary shadow-sm ring-1 ring-k-border-subtle'
                                                            : 'text-k-text-tertiary hover:text-k-text-primary hover:bg-glass-bg'
                                                        }
                                                    `}
                                                >
                                                    {workout.name}
                                                    {activeWorkoutId === workout.id && (
                                                        <span className="flex items-center gap-0.5 ml-1 border-l border-k-border-subtle pl-2">
                                                            <span
                                                                onClick={(e) => { e.stopPropagation(); duplicateWorkout(workout.id) }}
                                                                className="p-0.5 rounded text-k-text-quaternary hover:text-violet-400 transition-colors cursor-pointer"
                                                                title="Duplicar treino"
                                                            >
                                                                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                                                </svg>
                                                            </span>
                                                            {workouts.length > 1 && (
                                                                <span
                                                                    onClick={(e) => { e.stopPropagation(); deleteWorkout(workout.id) }}
                                                                    className="p-0.5 rounded text-k-text-quaternary hover:text-red-400 transition-colors cursor-pointer"
                                                                    title="Excluir treino"
                                                                >
                                                                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                                                    </svg>
                                                                </span>
                                                            )}
                                                        </span>
                                                    )}
                                                </button>
                                            </SortableWorkoutTab>
                                        ))}
                                    </div>
                                </SortableContext>
                            </DndContext>

                            <button
                                onClick={addWorkout}
                                className="w-8 h-8 flex items-center justify-center rounded-lg text-k-text-quaternary hover:text-k-text-primary hover:bg-glass-bg transition-all ml-2"
                                title="Adicionar Treino"
                            >
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 4v16m8-8H4" />
                                </svg>
                            </button>
                        </div>

                        {/* Workout Canvas — drop zone for exercises from library */}
                        <div
                            ref={canvasScrollRef}
                            onScroll={(e) => setIsCanvasScrolled(e.currentTarget.scrollTop > 40)}
                            onDragOver={handleCanvasDragOver}
                            onDragLeave={handleCanvasDragLeave}
                            onDrop={handleCanvasDrop}
                            className={`flex-1 overflow-y-auto p-6 scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent transition-colors duration-200 ${isDraggingOver ? 'bg-violet-500/5 ring-2 ring-inset ring-violet-500/20' : ''}`}
                        >
                            <div className="max-w-3xl mx-auto pb-20">
                                {activeWorkout ? (
                                    <WorkoutPanel
                                        workout={activeWorkout}
                                        exercises={localExercises}
                                        onUpdateName={(name) => updateWorkoutName(activeWorkout.id, name)}
                                        onAddExercise={() => { }} // Not used with drag/click
                                        onAddNote={() => addNote(activeWorkout.id)}
                                        onUpdateItem={(itemId, updates) => updateItem(activeWorkout.id, itemId, updates)}
                                        onDeleteItem={(itemId) => deleteItem(activeWorkout.id, itemId)}
                                        onMoveItem={(itemId, dir) => moveItem(activeWorkout.id, itemId, dir)}
                                        onReorderItem={handleReorderItem}
                                        onCreateSupersetWithNext={(itemId) => createSupersetWithNext(activeWorkout.id, itemId)}
                                        onAddToExistingSuperset={(itemId, supersetId) => addToExistingSuperset(activeWorkout.id, itemId, supersetId)}
                                        onRemoveFromSuperset={(supersetId, itemId) => removeFromSuperset(activeWorkout.id, supersetId, itemId)}
                                        onDissolveSuperset={(supersetId) => dissolveSuperset(activeWorkout.id, supersetId)}
                                        onUpdateFrequency={(days) => updateWorkoutFrequency(activeWorkout.id, days)}
                                        occupiedDays={occupiedDays}
                                        isScrolled={isCanvasScrolled}
                                    />
                                ) : (
                                    <div className="text-center py-20">
                                        <p className="text-k-text-quaternary text-sm">Selecione ou crie um treino para começar</p>
                                    </div>
                                )}

                                {/* Delete workout is now in the tab ⋯ menu */}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {/* Tour: Program Builder (auto-start on first visit) */}
            <TourRunner tourId="program_builder" steps={TOUR_STEPS.program_builder} autoStart />

            {/* Confirmation dialog — activate as current program */}
            {showActivateConfirm && (
                <div className="fixed inset-0 z-50 flex items-center justify-center">
                    <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" onClick={() => setShowActivateConfirm(false)} />
                    <div className="relative bg-surface-primary border border-k-border-subtle rounded-2xl shadow-2xl p-6 max-w-md w-full mx-4 animate-in zoom-in-95 fade-in duration-200">
                        <h3 className="text-base font-semibold text-k-text-primary mb-2">Ativar programa?</h3>
                        <p className="text-sm text-k-text-tertiary leading-relaxed">
                            O programa atual do aluno{studentContext?.activeProgramName && (
                                <> (&quot;<span className="text-k-text-secondary">{studentContext.activeProgramName}</span>&quot;)</>
                            )} será concluído e arquivado no histórico.
                        </p>
                        <p className="text-sm text-k-text-tertiary leading-relaxed mt-2">
                            O novo programa passará a ser exibido para o aluno imediatamente.
                        </p>
                        <div className="flex items-center justify-end gap-3 mt-6">
                            <Button
                                onClick={() => setShowActivateConfirm(false)}
                                variant="ghost"
                                className="rounded-full px-5 py-2 h-9 text-sm font-medium bg-white/[0.06] text-k-text-secondary hover:text-k-text-primary hover:bg-white/10 transition-all"
                            >
                                Cancelar
                            </Button>
                            <Button
                                onClick={() => { setShowActivateConfirm(false); saveProgram('immediate') }}
                                disabled={saving}
                                className="bg-violet-600 hover:bg-violet-500 text-white rounded-full px-5 py-2 h-9 text-sm font-medium transition-all"
                            >
                                {saving ? <Loader2 className="animate-spin w-4 h-4" /> : 'Confirmar Ativação'}
                            </Button>
                        </div>
                    </div>
                </div>
            )}

            {/* Dialog — save as template */}
            {showTemplateDialog && (
                <div className="fixed inset-0 z-50 flex items-center justify-center">
                    <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" onClick={() => setShowTemplateDialog(false)} />
                    <div className="relative bg-surface-primary border border-k-border-subtle rounded-2xl shadow-2xl p-6 max-w-md w-full mx-4 animate-in zoom-in-95 fade-in duration-200">
                        <h3 className="text-base font-semibold text-k-text-primary mb-1">Salvar como Modelo</h3>
                        <p className="text-sm text-k-text-tertiary leading-relaxed mb-5">
                            O programa será salvo na biblioteca de modelos para reutilizar com outros alunos.
                        </p>

                        <div className="space-y-4">
                            <div>
                                <label className="block text-[10px] font-bold text-k-text-quaternary uppercase tracking-widest mb-1.5">Nome do modelo</label>
                                <input
                                    type="text"
                                    value={templateName}
                                    onChange={(e) => setTemplateName(e.target.value)}
                                    placeholder="Ex: Hipertrofia 5x - Superior/Inferior"
                                    className="w-full bg-white/[0.04] border border-k-border-subtle rounded-xl px-3 py-2.5 text-sm text-k-text-primary placeholder:text-k-text-quaternary outline-none focus:border-violet-500/50 transition-colors"
                                    autoFocus
                                />
                            </div>

                            {isStudentContext && (
                                <label className="flex items-center gap-2.5 cursor-pointer group">
                                    <input
                                        type="checkbox"
                                        checked={alsoActivate}
                                        onChange={(e) => setAlsoActivate(e.target.checked)}
                                        className="w-4 h-4 rounded border-k-border-subtle bg-white/[0.04] text-violet-600 focus:ring-violet-500/30 focus:ring-offset-0 cursor-pointer"
                                    />
                                    <span className="text-sm text-k-text-tertiary group-hover:text-k-text-secondary transition-colors">
                                        Também ativar como programa atual do aluno
                                    </span>
                                </label>
                            )}
                        </div>

                        <div className="flex items-center justify-end gap-3 mt-6">
                            <Button
                                onClick={() => setShowTemplateDialog(false)}
                                variant="ghost"
                                className="rounded-full px-5 py-2 h-9 text-sm font-medium bg-white/[0.06] text-k-text-secondary hover:text-k-text-primary hover:bg-white/10 transition-all"
                            >
                                Cancelar
                            </Button>
                            <Button
                                onClick={saveAsTemplate}
                                disabled={!templateName.trim() || savingTemplate}
                                className="bg-violet-600 hover:bg-violet-500 text-white rounded-full px-5 py-2 h-9 text-sm font-medium transition-all"
                            >
                                {savingTemplate ? <Loader2 className="animate-spin w-4 h-4" /> : 'Salvar Modelo'}
                            </Button>
                        </div>
                    </div>
                </div>
            )}
        </AppLayout>
    )
}
